# 支付宝前端面试 2017-02-27  
头条失利面试后，特地来一趟杭州，26号上午去了滴滴，面试感觉还不错，让我等消息，希望感觉还是挺大的，下午去了支付宝面试，面试官人挺好的，整场面试下来，没啥太大压力，主要是自己的技术深度不够，应该是没过，不过还是有收获，写点东西记录一下  

## 笔试部分  
1. 说说对洗牌算法的理解和如何验证其正确性  
    洗牌算法之前没了解过，刚面到的时候好蒙，闲话不多说，这里说下洗牌算法的js实现  

    Fisher-Yates  
    这是最经典的洗牌算法，其算法思想是从原数组中随机抽取一个新的元素到新数组中  
    
    从还没处理的数组（假如还剩n个）中，产生一个[0,n]之间的随机数random

    从剩下的n个元素中把第random个元素取出到新数组中  
    
    删除原数组第random个元素  

    重复第2 3步直到所有的元素取完 

    最终返回一个新的打乱的数组  

    代码实现  
    ```  
    function shufle(arr){
        var result = [],
            random;
        while(arr.length > 0){
            random = Math.floor(Math.random() * arr.length);
            result.push(arr[random])
            arr.splice(random, 1)
        }
        return result;
    }
    ```  
    这种算法的时间复杂度是O(n2)  

参考链接 [洗牌算法的js实现](https://github.com/ccforward/cc/issues/44)  
参考链接 [Fisher–Yates shuffle 洗牌算法](https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/)  

2. 还有一道是求解一颗树的最大权重的路径，对算法真的是功底比较薄弱，没耽搁时间，直接说不会  

## 面试部分  
面试官人很好，问的也很全面，没过完全是自己的问题，自己的技术积累还不到家，这里就暂时不为每个题目解答了，先把记得的题目写一下  
1. 说一说你对highChart和EChart的理解，以及两者的区别，除了这两个还用过别的插件吗，分别说下他们的不同？  

2. 说一下你对事件委托和事件代理的理解？  
    什么是事件委托？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件，当我们需要对很多元素添加事件的时候，可以通过事件添加到他们的父节点二将时间委托给父节点来触发处理函数  

    为什么要使用事件委托？   
    一般来说，dom需要有事件处理程序，我们都会直接给它设置事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们这里有100个li，每个li都有相同的click事件，那么我们会用for循环的方法来遍历所有的li，然后给他们添加事件，那么这样会存在什么问题呢？  
    在JavaScript中，添加到页面上的事件处理程序的数量将直接关联到页面整体的运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数就越多，就会延长整个页面交互就绪时间，这就是为什么性能优化的主要思想是减少dom操作的原因，如果使用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能  
    每个函数都是一个对象，是对象就会占用内存，内存占用率就越大，自然性能就差了，比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，如果使用事件委托，那么我们就可以只对它的父级这一个对象（如果只有一个父级）进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好  

    事件委托的原理？  
    事件委托是利用事件的冒泡机制来实现的，何为事件冒泡呢？这里介绍下浏览器dom事件处理的过程，dom2.0模型将事件流程分为三个阶段：事件捕获阶段，事件目标阶段，事件冒泡阶段。  
    事件捕获：当某个元素触发某个事件，顶层对象document就会发出一个事件流，随着dom树的节点向目标元素节点流去，直到到达事件真正发生的目标元素，在这个过程中，事件相应的监听函数是不会被触发的  
    事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数，如果没有绑定监听函数，那就不执行  
    事件冒泡：从目标元素开始，往顶层元素传播，途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发，如果想阻止事件冒泡，可以使用event.stopPropgation()或者event.cancelBubble=true来阻止事件的冒泡传播  

    事件委托怎么实现：  
    Event对象提供了一个属性叫target，可以返回事件的目标节点，我们称为事件源，也就是说，target就可以表示为当前事件操作的dom，但是不是真正操作的dom，当然，这个是有兼容性的，标准浏览器用event.target，IE浏览器用event.srcElement，此时知识获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，一般转化为小写再进行比较  
    如果你想将事件委托给父元素来处理，但每个子元素的事件内容又不相同时，这里我们可以给每个子元素添加一个唯一的key来作标识，然后在父元素中对其进行分别的处理
    ```
    const list = document.querySelector('#list)  
    const lists = list.querySelector('#list > li')
    for(let i=0; i<lists.length; i++){
        lists[i].dataset.key = 'list-' + i
    }
    list.addEventListener('click',function(e){
        const event = e || window.event
        const target = event.target || event.srcElement  
        if(target.nodeName.toLocaleLowerCase() === 'li'){
            switch(target.dataset.key){
                case 'list-1':
                    do something-1
                    break
                case 'list-2':
                    do something-2
                    break
                ...
                default:
                    do something-3
                    break
            }
        }
    })  
    ```  
参考链接 [JavaScrip事件代理和委托](https://www.cnblogs.com/owenChen/archive/2013/02/18/2915521.html)  
参考链接 [JS的事件委托和事件代理详解](https://www.cnblogs.com/liugang-vip/p/5616484.html)  



3. 说一下你对css重绘和重排的理解，两个有什么不同？  

4. 说一下你对进程和线程的理解？node的多线程怎么处理？  

5. 说一下你对node中Buffer和stream的理解，两者有什么不同，怎么处理？  

6. 说一下jQuery中ready的实现